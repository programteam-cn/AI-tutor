[
  {
    "problem_id": 38177,
    "problem_name": "Employee-Project Combinations",
    "primary_topic": "Cross Join",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Cross JOIN 1 (Core Syntax and Cartesian Product)",
    "topic_id": "cross_join",
    "cluster_id": "cross_c1",
    "description": "#### The company wants to explore all possible employee-project assignments to optimize workforce distribution. This allows HR to explore new employee-project allocations.\n<br>\n\n#### Write a query to generate a list of all possible employee-project assignments.\n<br>\n\n\n#### Table: <b> employees</b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:37%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;employee_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;employee_name  </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;manager_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;salary_id    </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n</tbody>\n</table>\n<br>\n\n#### Table: <b> projects </b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:35.5%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;project_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;project_name  </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n</tbody>\n</table>\n<br>\n\n\n#### <b>Note:</b> Retrieve only the columns specified in the expected output.\n<br>\n\n##### Expected Output:\n<br>\n\n<img src = \"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004796_1740653056_q5.png\">",
    "brief_summary": "This problem tests the SQL concept of cross join to generate all possible combinations between two tables: employees and projects. Key skills include performing a cross join (Cartesian product) and selecting specific columns without filtering or aggregation."
  },
  { 
    "problem_id": 32539,
    "problem_name": "Linked Orders",
    "primary_topic": "Inner Join",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "1",
    "cluster": "Inner join 1 (Simple Join)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c1",
    "description": "#### You are an analyst and you have been given the following two tables:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Orders </b> <br> \n\n<ul>\n<li>orderNumber (int)- The primary key for the orders table.\n</li>\n<li>orderDate (date)- The date of order. </li>\n<li>requiredDate(date)- The date by which the order is required.</li>\n<li>shippedDate (date)-The date when the order was shipped.\n</li>\n<li>status(varchar(15)) - The status of the order (e.g., processing, shipped, delivered).</li>\n<li>Comments (text)-Additional comments or notes related to the order.</li>\n<li>customerNumber (int)- The identification number of the customer placing the order.</li>\n</ul>\n\n#### <b>Input: </b>\n#### <b> Table Name 2: Customers </b> \n<ul>\n<li>customerNumber (int)- The unique identification number for each customer.</li> \n<li>customerName( varchar(50))- The name of the customer.</li>\n<li>contactLastName (varchar(50)) -The last name of the primary contact person for the customer.</li>\n<li>contactFirstName (varchar(50)) -The first name of the primary contact person for the customer. </li>\n<li>phone (varchar(50))- The phone number of the customer.</li>\n<li>addressLine1 (varchar(50))- The first line of the customer's address.</li>\n<li>addressLine2 (varchar(50))-The second line of the customer's address (optional).</li>\n<li>city (varchar(50)) - The city where the customer is located.</li>\n<li>State (varchar(50)) - The state or region where the customer is located.</li>\n<li>postalCode (varchar(15))- The postal code or ZIP code of the customer's location.</li>\n<li>country(varchar(50))- The country where the customer is located. </li>\n<li>salesRepEmployeeNumber (int )- The employee number of the sales representative assigned to the customer. </li>\n<li>creditLimit (decimal (10,2))-The credit limit for the customer. </li>\n</ul>\n\n#### As an analyst, your job is to visualize different scenarios. Currently, you want to know all the orders linked to customers. Join the two tables so that the resulting set has the data that is common in both tables.\n#### Print orderNumber for such orders. <br> <br> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003770_1718879441_Screenshot 2024-06-20 160001.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests the concept of inner joins by linking the Orders and Customers tables on customerNumber. Key skills include performing inner joins to filter and retrieve only matching records, focusing on join operations without aggregation or complex filtering."
  },
  {
    "problem_id": 17030,
    "problem_name": "orders-customers",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "1",
    "cluster": "Inner join 1 (Simple Join)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c1",
    "description": "#### Consider the following two tables.\n\n    Table- orders\n    orderNumber       | int                | \n    orderDate            | date             | \n    requiredDate       | date             | \n    shippedDate        | date             | \n    status                   | varchar(15) | \n    comments            | text              | \n    customerNumber | int                |\n\n    Table- customers\n    customerNumber                  | int                 | \n    customerName                     | varchar(50)   |\n    contactLastName                 | varchar(50)   | \n    contactFirstName                 | varchar(50)   | \n    phone                                   | varchar(50)   |\n    addressLine1                        | varchar(50)   | \n    addressLine2                        | varchar(50)   | \n    city                                        | varchar(50)   | \n    state                                      | varchar(50)   | \n    postalCode                            | varchar(15)   | \n    country                                  | varchar(50)   | \n    salesRepEmployeeNumber  | int                  | \n    creditLimit                             | decimal(10,2) | \n\n#### As an analyst your job is to visualize different scenarios. Currently, you want to know all the orders linked to customers. Join the two tables so that the resulting set has the data that are common in both the tables. \n\n    Print orderNumber for such orders.",
    "brief_summary": "This problem tests the concept of inner joins by linking the orders and customers tables on customerNumber. Key skills include performing an equi-join to filter and retrieve only matching records, focusing on basic join operations without aggregation or complex filtering."
  },
  {
    "problem_id": 38712,
    "problem_name": "2-Topping Pizzas",
    "primary_topic": "Inner Join (Theta)",
    "secondary_topic": "Conact, sorting",
    "difficulty": "Hard",
    "level": "2",
    "cluster": "Inner join 2 (Complex Join Condition)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c2",
    "description": "#### A popular pizza brand is introducing a new promotion where all 2-topping pizzas will be available at a fixed price. To evaluate the cost implications, they need an analysis of different 2-topping combinations and their total ingredient costs.\n<br>\n\n#### Write a query to retrieve all possible unique 2-topping pizza combinations and calculate their total cost.\n<br>\n\n##### Requirements:\n<br>\n\n<li>Each topping must be unique, no repeating ingredients in a single pizza.\n<li>Sort toppings alphabetically within each combination. Example: \"Chicken,Onions\" is valid, but \"Onion,Chicken\" is not.\n<li>Sort the results by total cost in descending order.\n<li>Break ties alphabetically based on the first topping, then the second.\n<li>Format output carefully with ingredient names separated by commas, with no spaces before or after.\n \n<br>\n\n#### Table: <b> pizza_toppings   </b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:45%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;topping_name   </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;ingredient_cost   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n</tbody>\n</table>\n<br/>\n\n\n##### Expected Output:\n<br>\n<img src = \"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004847_1742366714_in5.png\">\n<br>\n\n##### Explanation:\n<br>\n\n<li> The combination \"Chicken, Jalapenos\" has the highest total cost:  335 (Chicken),419 (Jalapenos) = 774\n<li>The results are sorted in descending order of total cost.\n<li>Ties are broken alphabetically, ensuring consistent ordering.",
    "brief_summary": "This problem tests inner join with complex theta conditions to generate unique 2-topping combinations from the pizza_toppings table. Key skills include self-joining, filtering duplicates, string concatenation, sorting alphabetically within pairs, and ordering results by aggregated cost and alphabetical tie-breakers."
  },
  {
    "problem_id": 32565,
    "problem_name": "Order Numbers",
    "primary_topic": "Inner Join",
    "secondary_topic": "Filtration",
    "difficulty": "Easy",
    "level": "1",
    "cluster": "Inner join 3 (Post-Join Filtering)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c3",
    "description": "#### You are an analyst and you have been given the following two tables:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Orders </b> <br> \n\n<ul>\n<li>orderNumber (int)- The primary key for the orders table.\n</li>\n<li>orderDate (date)- The date of order. </li>\n<li>requiredDate(date)- The date by which the order is required.</li>\n<li>shippedDate (date)-The date when the order was shipped.\n</li>\n<li>status(varchar(15)) - The status of the order (e.g., processing, shipped, delivered).</li>\n<li>Comments (text)-Additional comments or notes related to the order.</li>\n<li>customerNumber (int)- The identification number of the customer placing the order.</li>\n</ul>\n\n#### <b>Input: </b> <br>\n#### <b> Table Name 2: Customers </b> \n<ul>\n<li>customerNumber (int)- The unique identification number for each customer.</li> \n<li>customerName( varchar(50))- The name of the customer.</li>\n<li>contactLastName (varchar(50)) -The last name of the primary contact person for the customer.</li>\n<li>contactFirstName (varchar(50)) -The first name of the primary contact person for the customer. </li>\n<li>phone (varchar(50))- The phone number of the customer.</li>\n<li>addressLine1 (varchar(50))- The first line of the customer's address.</li>\n<li>addressLine2 (varchar(50))-The second line of the customer's address (optional).</li>\n<li>city (varchar(50)) - The city where the customer is located.</li>\n<li>State (varchar(50)) - The state or region where the customer is located.</li>\n<li>postalCode (varchar(15))- The postal code or ZIP code of the customer's location.</li>\n<li>country(varchar(50))- The country where the customer is located. </li>\n<li>salesRepEmployeeNumber (int )- The employee number of the sales representative assigned to the customer. </li>\n<li>creditLimit (decimal (10,2))-The credit limit for the customer. </li>\n</ul>\n\n#### Write an SQL query to find out the order numbers of the 'Atelier Graphique' (customer name). <br> <br> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003783_1718886866_Screenshot 2024-06-20 180402.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests the concept of inner joins between two tables: Orders and Customers. Key skills include performing inner joins on customerNumber, filtering results by customerName, and selecting specific columns to retrieve order numbers for a given customer."
  },
  {
    "problem_id": 32570,
    "problem_name": "Purchase Information",
    "primary_topic": "Inner Join",
    "secondary_topic": "Filtration, Sorting",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Inner join 3 (Post-Join Filtering)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c3",
    "description": "#### Retrieve detailed purchase information for customers named Michael and Olivia, including their first names, order dates, item descriptions, and total costs. <br>\n#### Sort the results based on the customer ID in ascending order. <br> <br> \n\n#### <b>Input:</b> <br> \n#### <b>Table Name 1: Customers </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004070_1720504401_Screenshot 2024-07-09 112225.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: Orders </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003796_1718895427_Screenshot 2024-06-20 202605.png\" alt=\"Italian Trulli\"> \n\n#### <b> Output: </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004071_1720504414_Screenshot 2024-07-09 112246.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests the use of inner joins between the Customers and Orders tables, focusing on filtering joined results by customer names. Key skills include performing inner joins, applying post-join filtering, selecting specific columns, and sorting the output by customer ID."
  },
  {
    "problem_id": 16705,
    "problem_name": "Atelier graphique",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": "Filtration",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Inner join 3 (Post-Join Filtering)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c3",
    "description": "#### Consider the following two tables.\n\n    Table- orders\n    orderNumber       | int                | \n    orderDate            | date             | \n    requiredDate       | date             | \n    shippedDate        | date             | \n    status                   | varchar(15) | \n    comments            | text              | \n    customerNumber | int                |\n\n    Table- customers\n    customerNumber                  | int                 | \n    customerName                     | varchar(50)   |\n    contactLastName                 | varchar(50)   | \n    contactFirstName                 | varchar(50)   | \n    phone                                   | varchar(50)   |\n    addressLine1                        | varchar(50)   | \n    addressLine2                        | varchar(50)   | \n    city                                        | varchar(50)   | \n    state                                      | varchar(50)   | \n    postalCode                            | varchar(15)   | \n    country                                  | varchar(50)   | \n    salesRepEmployeeNumber  | int                  | \n    creditLimit                             | decimal(10,2) | \n\n#### Now that you have connected the two tables- orders and customers, write a query to find out the  order numbers of 'Atelier graphique' (customer name).",
    "brief_summary": "This problem tests the concept of inner joins by combining the orders and customers tables. It requires joining on customerNumber, filtering for a specific customerName ('Atelier graphique'), and selecting relevant order numbers. Key skills include inner joins and post-join filtering."
  },
  {
    "problem_id": 32541,
    "problem_name": "Common Information",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Inner join 4 (Multi-Table Join)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c4",
    "description": "#### You are an analyst and you have been given the following three tables:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Orders </b> <br> \n\n<ul>\n<li>orderNumber (int)- The primary key for the orders table.\n</li>\n<li>orderDate (date)- The date of order. </li>\n<li>requiredDate(date)- The date by which the order is required.</li>\n<li>shippedDate (date)-The date when the order was shipped.\n</li>\n<li>status(varchar(15)) - The status of the order (e.g., processing, shipped, delivered).</li>\n<li>Comments (text)-Additional comments or notes related to the order.</li>\n<li>customerNumber (int)- The identification number of the customer placing the order.</li>\n</ul>\n\n#### <b>Table Name 2: OrderDetails </b> <br> \n\n<ul>\n<li>orderNumber (int)- The unique identification number for each order. </li>\n<li>productCode (varchar(15))- The code or identifier for the product being ordered. </li>\n<li>quantityOrdered (int)- The quantity of the product ordered in each order.</li>\n<li>priceEach (decimal(10,2))- The price per unit of the product.\n</li>\n<li>orderLineNumber (smallint)- The line number indicating the sequence of items on order.</li>\n</ul>\n\n#### <b>Input: </b> <br>\n#### <b> Table Name 3: Customers </b> \n<ul>\n<li>customerNumber (int)- The unique identification number for each customer.</li> \n<li>customerName( varchar(50))- The name of the customer.</li>\n<li>contactLastName (varchar(50)) -The last name of the primary contact person for the customer.</li>\n<li>contactFirstName (varchar(50)) -The first name of the primary contact person for the customer. </li>\n<li>phone (varchar(50))- The phone number of the customer.</li>\n<li>addressLine1 (varchar(50))- The first line of the customer's address.</li>\n<li>addressLine2 (varchar(50))-The second line of the customer's address (optional).</li>\n<li>city (varchar(50)) - The city where the customer is located.</li>\n<li>State (varchar(50)) - The state or region where the customer is located.</li>\n<li>postalCode (varchar(15))- The postal code or ZIP code of the customer's location.</li>\n<li>country(varchar(50))- The country where the customer is located. </li>\n<li>salesRepEmployeeNumber (int )- The employee number of the sales representative assigned to the customer. </li>\n<li>creditLimit (decimal (10,2))-The credit limit for the customer. </li>\n</ul>\n\n#### You are tasked with analyzing orders along with their associated customer details and order details. The three tables involved are orders, customers, and orderdetails. Your goal is to connect these tables to retrieve the common information and print the orderNumber for each order in the result set.\n#### Print orderNumber for such orders. <br> <br> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004084_1720703999_Screenshot 2024-07-11 184938.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests the concept of inner joins across multiple tables—Orders, OrderDetails, and Customers. Key skills include performing multi-table equi-joins to combine related data and filtering to retrieve specific order numbers based on linked customer and order details."
  },
  {
    "problem_id": 33237,
    "problem_name": "Nature of Transaction",
    "primary_topic": "Inner Join/Self Join",
    "secondary_topic": "Case, Aggregation",
    "difficulty": "Medium",
    "level": "3",
    "cluster": "Inner join 4 (Multi-Table Join)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c4",
    "description": "#### To meet compliance requirements, the finance team needs to identify the nature of transactions conducted by the company. Specifically, you are required to analyze transaction data for the first quarter of 2024 (January to March). \n<br>\n\n#### Your task is to create a new column in the dataset that indicates whether each transaction is international (where the sender and recipient are from different countries) or domestic (where the sender and recipient are from the same country). Additionally, provide a count of the number of international and domestic transactions for this period. \n<br>\n\n#### This classification will assist in ensuring compliance with relevant regulations and provide insights into the distribution of transaction types. Please include a detailed summary of the counts for each type of transaction.\n<br> \n\n#### <b>Hints:  </b> \n<ul> \n<li> Use the Transactions and Users tables.</li> \n</ul> \n<br> \n\n#### <b> Output Format: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004125_1721635631_Screenshot 2024-07-22 002206.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests inner and self join concepts using the Transactions and Users tables. Key skills include joining multiple tables to compare sender and recipient countries, filtering transactions by date, creating conditional columns, and aggregating counts of international versus domestic transactions."
  },
  {
    "problem_id": 17031,
    "problem_name": "orders-customers-orderdetails",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Inner join 4 (Multi-Table Join)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c4",
    "description": "#### Consider the following three tables.\n\n    Table- orders\n    orderNumber       | int                | \n    orderDate            | date             | \n    requiredDate       | date             | \n    shippedDate        | date             | \n    status                   | varchar(15) | \n    comments            | text              | \n    customerNumber | int                |\n\n    Table- orderdetails\n    orderNumber       | int                   | \n    productCode        | varchar(15)    | \n    quantityOrdered   | int                   | \n    priceEach             | decimal(10,2) | \n    orderLineNumber | smallint           |\n\n    Table- customers\n    customerNumber                  | int                 | \n    customerName                     | varchar(50)   |\n    contactLastName                 | varchar(50)   | \n    contactFirstName                 | varchar(50)   | \n    phone                                   | varchar(50)   |\n    addressLine1                        | varchar(50)   | \n    addressLine2                        | varchar(50)   | \n    city                                        | varchar(50)   | \n    state                                      | varchar(50)   | \n    postalCode                            | varchar(15)   | \n    country                                  | varchar(50)   | \n    salesRepEmployeeNumber  | int                  | \n    creditLimit                             | decimal(10,2) | \n\n\n#### Previously you linked two tables together, that is orders and customers. You now want to analyze the details of these orders too. Connect the three tables- orders, customers and orderdetails such that the result set contains the information that is common to all three tables. \n\n    Print orderNumber for such orders.",
    "brief_summary": "This problem tests the concept of inner joins across multiple tables—orders, customers, and orderdetails. Key skills include performing multi-table equi-joins to combine related data and filtering to ensure only records present in all three tables are returned."
  },
  {
    "problem_id": 32579,
    "problem_name": "Total Quantity Sold",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": "Aggregation",
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Inner join 5 (Join with Aggregation)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c5",
    "description": "#### Consider the following tables in a database:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Suppliers</b> <br> \n\n<ul>\n<li>SupplierID: Unique identifier for each supplier. </li>\n<li>SupplierName: Name of the supplier.</li>\n<li>ContactName: Name of the contact person at the supplier.</li>\n<li>Address: Supplier's address.</li>\n<li>City: City where the supplier is located.</li>\n<li>PostalCode: Postal code of the supplier's location.</li>\n<li>Country: Country where the supplier is located.</li>\n<li>Phone: Contact phone number for the supplier.</li>\n</ul>\n\n#### <b>Table Name 2: Products </b> <br> \n\n<ul>\n<li>ProductID (Primary Key): Unique identifier for each product. </li>\n<li>ProductName: Name of the product. </li>\n<li>SupplierID: The ID of the supplier for each product. </li> \n<li>CategoryID (Foreign Key): Identifier linking the product to its category.</li>\n<li>Unit: Measurement unit in which the product is sold.\n</li>\n<li>Price: Price of the product.</li>\n</ul>\n\n#### <b> Table Name 3: Order_Details </b> \n<ul>\n<li>OrderID (Foreign Key): Identifier linking the order to a specific order in the Orders table.</li> \n<li>ProductID (Foreign Key): Identifier linking the order to a specific product in the Products table.</li>\n<li>Quantity: The quantity of the product ordered in this order.</li>\n</ul>\n\n\n#### Write an SQL query to find the total quantity of products sold for each supplier. Your query should include the supplier name and the total quantity of products sold by that supplier.\n <br> <br> \n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003806_1718952248_Screenshot 2024-06-21 121352.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests inner join concepts involving the Suppliers, Products, and Order_Details tables. Key skills include performing equi-joins across multiple tables, filtering by supplier, and aggregating total product quantities sold per supplier using GROUP BY."
  },
  {
    "problem_id": 32584,
    "problem_name": "Highest Trades",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": "Aggregation and Filtering",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Inner join 5 (Join with Aggregation)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c5",
    "description": "#### Assuming you have access to the tables containing information about completed trade orders (trades) and user details (users) in a Robinhood trading system, your task is to create a query that retrieves the top three cities with the highest number of completed trade orders, listed in descending order. The output should display the city name and the corresponding total number of completed trade orders. <br> <br>\n\n#### <b>Input: </b>  <br>\n#### <b>Table Name 1: Trades </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003809_1718954343_Screenshot 2024-06-21 124543.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: Users </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003810_1718954393_Screenshot 2024-06-21 124611.png\" alt=\"Italian Trulli\"> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003811_1718954429_Screenshot 2024-06-21 124640.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests inner join concepts by combining the Trades and Users tables to aggregate data. Key skills include performing an equi-join, filtering completed trades, grouping by city, and ordering results to find the top three cities with the highest trade counts."
  },
  {
    "problem_id": 32578,
    "problem_name": "Total Revenue",
    "primary_topic": "Inner Join",
    "secondary_topic": "Aggregation",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Inner join 5 (Join with Aggregation)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c5",
    "description": "#### Consider the following tables in a database:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Customers</b> <br> \n\n<ul>\n<li>customerId: Unique identifier for each customer. </li>\n<li>customerName: Full name of the customer.</li>\n<li>First_name: First name of the customer.</li>\n<li>Last_name: Last name of the customer.</li>\n<li>Address: Customer's address.</li>\n<li>City_code: Code representing the city where the customer is located.</li>\n<li>Country: Country where the customer is located.</li>\n</ul>\n\n#### <b>Table Name 2: Products </b> <br> \n\n<ul>\n<li>ProductID (Primary Key): Unique identifier for each product. </li>\n<li>ProductName: Name of the product. </li>\n<li>CategoryID (Foreign Key): Identifier linking the product to its category.</li>\n<li>Unit: Measurement unit in which the product is sold.\n</li>\n<li>Price: Price of the product.</li>\n</ul>\n\n#### <b> Table Name 3: Order_Details </b> \n<ul>\n<li>OrderID (Foreign Key): Identifier linking the order to a specific order in the Orders table.</li> \n<li>ProductID (Foreign Key): Identifier linking the order to a specific product in the Products table.</li>\n<li>Quantity: The quantity of the product ordered in this order.</li>\n</ul>\n\n#### <b> Table Name 4: Orders </b> \n<ul>\n<li>OrderID (Primary Key): Unique identifier for each order.</li> \n<li>CustomerID (Foreign Key): Identifier linking the order to a specific customer in the Customers table.</li>\n<li>EmployeeID (Foreign Key): Identifier linking the order to a specific employee in the Employees table.</li>\n<li>OrderDate: Date when the order was placed.</li>\n<li>ShipperID (Foreign Key):  Identifier linking the order to a specific shipper in the Shippers table. </li>\n</ul>\n\n#### Write a SQL query to find the total revenue generated from each country, rounded to two decimal places. Your query should include the country name and the total revenue (rounded to 2 places) from orders made by customers in that country.\n <br> <br> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003804_1718951650_Screenshot 2024-06-21 120352.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests inner joins combined with aggregation. It involves the Customers, Orders, Order_Details, and Products tables. Key skills include performing multiple inner joins, filtering by country, calculating total revenue using quantity and price, and rounding aggregated results."
  },
  {
    "problem_id": 32580,
    "problem_name": "Total Purchased Amount",
    "primary_topic": "Inner Join",
    "secondary_topic": "Aggregation, Sorting",
    "difficulty": "Medium",
    "level": "2",
    "cluster": "Inner join 5 (Join with Aggregation)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c5",
    "description": "#### Consider the following tables in a database:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Customers</b> <br> \n\n<ul>\n<li>customerId: Unique identifier for each customer. </li>\n<li>customerName: Full name of the customer.</li>\n<li>First_name: First name of the customer.</li>\n<li>Last_name: Last name of the customer.</li>\n<li>Address: Customer's address.</li>\n<li>City_code: Code representing the city where the customer is located.</li>\n<li>Country: Country where the customer is located.</li>\n</ul>\n\n#### <b>Table Name 2: Products </b> <br> \n\n<ul>\n<li>ProductID (Primary Key): Unique identifier for each product. </li>\n<li>ProductName: Name of the product. </li>\n<li>CategoryID (Foreign Key): Identifier linking the product to its category.</li>\n<li>Unit: Measurement unit in which the product is sold.\n</li>\n<li>Price: Price of the product.</li>\n</ul>\n\n#### <b> Table Name 3: Order_Details </b> \n<ul>\n<li>OrderID (Foreign Key): Identifier linking the order to a specific order in the Orders table.</li> \n<li>ProductID (Foreign Key): Identifier linking the order to a specific product in the Products table.</li>\n<li>Quantity: The quantity of the product ordered in this order.</li>\n</ul>\n\n#### <b> Table Name 4: Orders </b> \n<ul>\n<li>OrderID (Primary Key): Unique identifier for each order.</li> \n<li>CustomerID (Foreign Key): Identifier linking the order to a specific customer in the Customers table.</li>\n<li>EmployeeID (Foreign Key): Identifier linking the order to a specific employee in the Employees table.</li>\n<li>OrderDate: Date when the order was placed.</li>\n<li>ShipperID (Foreign Key):  Identifier linking the order to a specific shipper in the Shippers table. </li>\n</ul>\n\n#### Using the above tables, write a SQL query to find the top 5 customers by their total purchase amount (rounded to 2 decimal places), considering the price and quantity of each product they ordered. Your query should return the customer's name (CustomerName) and their total purchase amount (TotalPurchaseAmount).\n <br> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003807_1718952512_Screenshot 2024-06-21 121818.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests inner joins and aggregation by combining Customers, Orders, Order_Details, and Products tables. Key skills include joining multiple tables, calculating total purchase amounts using price and quantity, grouping by customer, and sorting to find the top 5 customers."
  },
  {
    "problem_id": 32641,
    "problem_name": "Top Common Actions",
    "primary_topic": "Inner Join (Equi)",
    "secondary_topic": "Aggregation, Filtration",
    "difficulty": "Hard",
    "level": "1",
    "cluster": "Inner join 5 (Join with Aggregation)",
    "topic_id": "inner_join",
    "cluster_id": "inner_c5",
    "description": "#### The product team wants to understand the most common actions performed by users who have made a booking, as well as the devices they use for these actions. This information can help in optimizing the user experience and tailoring the interface to common user behaviors. \n<br>\n\n#### Write a SQL query to identify the top 5 most common actions performed by users who made a booking (i.e., country_destination is not 'NDF') and the devices they use for these actions.\n<br>\n\n#### Identify the top 5 most common actions performed by users who made a booking and the devices they use for these actions. \n<br>\n\n#### <b> Instructions:</b>\n<ul>\n<li> It is suggested to explore the data using the DESCRIBE and SELECT statement before writing the queries which will help to understand the relationship between tables. </li>\n</ul>\n<br> \n\n#### <b>Hints: \n<ol> \n<li> Use the Users and the sessions_data table.</li> \n<li> The country_destination column has ‘NDF’ entries which implies Not Defined. The output should not contain the countries as Not Defined. </li>\n</ol>\n<br>\n\n#### <b> Output Format: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003908_1719323626_Screenshot 2024-06-25 192331.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests inner join and aggregation concepts using the Users and sessions_data tables. It requires filtering users with valid bookings (country_destination ≠ 'NDF'), joining tables on user IDs, grouping by action and device, and ranking to find the top 5 most common actions and devices."
  },
  {
    "problem_id": 32568,
    "problem_name": "Customer Profiles",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "1",
    "cluster": "Outer JOIN 1 (Simple Join)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c1",
    "description": "#### You're tasked with retrieving comprehensive customer information from a database. The relevant data is stored in two separate tables: Customers and Orders.\n#### Your goal is to craft an SQL query that effectively combines these tables to reveal complete customer profiles, including names, addresses, and order details. Ensure that all customers are included in the output, even if they haven't placed any orders. <br> <br> \n\n#### <b>Input:</b> <br> \n#### <b>Table Name 1: Customers </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003789_1718889396_Screenshot 2024-06-20 184539.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: Orders </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003790_1718889405_Screenshot 2024-06-20 184557.png\" alt=\"Italian Trulli\"> \n#### <b> Output: </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003791_1718889415_Screenshot 2024-06-20 184615.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests the concept of left outer joins by combining Customers and Orders tables. It requires joining these tables to include all customers, even those without orders, demonstrating skills in outer joins and data retrieval without filtering out unmatched records."
  },
  {
    "problem_id": 38173,
    "problem_name": "Employee Department Overview",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Outer JOIN 1 (Simple Join)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c1",
    "description": "#### The company wants to retrieve a list of all employees along with their departments details. Employees who are not assigned to any departments should still be included in the results. This helps HR identify employees without an assigned department.\n<br>\n\n#### Write a query to retrieve the employee&lowbar;id and employee&lowbar;name of all employees, along with their respective department&lowbar;name and location, by joining the relevant tables.\n<br>\n\n#### Table: <b> employees</b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:40%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;employee_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;employee_name  </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;manager_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;salary_id    </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n</tbody>\n</table>\n<br>\n\n#### Table: <b> departments </b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:40%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;department_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_name  </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;location   </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n</tbody>\n</table>\n\n\n<br>\n#### <b>Note:</b> Retrieve only the columns specified in the expected output.\n\n<br>\n\n##### Expected Output:\n<br>\n\n<img src = \"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004791_1740651840_q1.png\">",
    "brief_summary": "This problem tests the concept of left outer joins by combining the employees and departments tables. It requires retrieving all employees, including those without departments, using joins and filtering to display employee and department details. Key skills include outer joins and basic data selection."
  },
  {
    "problem_id": 38174,
    "problem_name": "Department Project Report",
    "primary_topic": "Outer Join (Right)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Outer JOIN 1 (Simple Join)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c1",
    "description": "#### The company wants a report showing all projects along with the department managing them. If a department has no assigned projects, it should still be included. This helps management track departments that are not involved in any projects. \n<br>\n\n#### Write a query to retrieve a list of all projects along with their respective departments, ensuring that all departments are included, even if they have no associated projects.\n<br>\n\n#### Table: <b> departments </b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:40%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;department_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_name  </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;location   </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n</tbody>\n</table>\n<br>\n\n\n#### Table: <b> projects </b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:40%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;project_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;project_name  </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n</tbody>\n</table>\n<br>\n\n\n####<b> Note</b>: Retrieve only the columns specified in the expected output.\n<br>\n\n\n##### Expected Output:\n<br>\n\n<img src = \"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004792_1740651920_q2.png\">",
    "brief_summary": "This problem tests the use of outer joins, specifically a right join, between the departments and projects tables. It requires retrieving all departments with their projects, including those without any projects. Key skills include outer joins and filtering to handle unmatched records."
  },
  {
    "problem_id": 32567,
    "problem_name": "Employee Bonus",
    "primary_topic": "Logical (Anti Join)",
    "secondary_topic": "Filtration",
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Outer JOIN 2 (Post-Join Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c2",
    "description": "#### Write an SQL query to generate a report of employee names and their bonus amounts for those employees whose bonus is less than 1000.  <br> <br> \n\n#### <b>Input:</b> <br> \n#### <b>Table Name 1: Employee </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003785_1718887819_Screenshot 2024-06-20 181851.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: Bonus </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003786_1718887829_Screenshot 2024-06-20 181918.png\" alt=\"Italian Trulli\"> \n#### <b> Output: </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003788_1718889098_Screenshot 2024-06-20 183523.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests the concept of logical anti-joins and post-join filtering. It involves the Employee and Bonus tables, requiring skills in joining tables, filtering results based on conditions (bonus < 1000), and selecting specific columns for the final report."
  },
  {
    "problem_id": 32569,
    "problem_name": "Customer Orders",
    "primary_topic": "Logical (Anti Join)",
    "secondary_topic": "Filtration",
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Outer JOIN 2 (Post-Join Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c2",
    "description": "#### Given two tables - Customers and Orders, with the schema described below, write a query to find all customers who have never placed any orders. <br> <br> \n\n#### <b> Customers Table Schema: </b>\n<ul>\n<li> id (integer) - Primary key, a unique identifier for each customer. </li>\n<li> name (varchar) - Name of the customer. </li>\n</ul>\n\n#### <b> Orders Table Schema: </b>\n<ul> <li> id (integer) - Primary key, the unique identifier for each order. </li> \n<li> customerId (integer) - Foreign key referencing the id column of the Customers table, indicating the customer who placed the order. </li> \n</ul>\n<br> \n\n#### <b>Input:</b> <br> \n#### <b>Table Name 1: Customers </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003792_1718894400_Screenshot 2024-06-20 185854.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: Orders </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003793_1718894410_Screenshot 2024-06-20 185911.png\" alt=\"Italian Trulli\"> \n#### <b> Output: </b><br>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003794_1718894419_Screenshot 2024-06-20 185952.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests the concept of anti-join using two tables: Customers and Orders. It requires identifying customers without orders by applying outer joins combined with post-join filtering. Key skills include performing left joins and filtering for null values to find unmatched records."
  },
  {
    "problem_id": 13625,
    "problem_name": "IMDb Rating",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Filtration",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Outer JOIN 2 (Post-Join Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c2",
    "description": "#### Retrieve the title and rating of movies from the IMDb dataset that were released in 2014, belong to a genre starting with 'C', and had a budget exceeding 4 Crore.",
    "brief_summary": "This problem tests the use of left outer joins with post-join filtering on IMDb movie and genre tables. Key skills include performing outer joins, filtering by release year, genre prefix, and budget, and selecting specific movie attributes like title and rating."
  },
  {
    "problem_id": 15083,
    "problem_name": "SQL Query- 6",
    "primary_topic": "Outer Join (Right)",
    "secondary_topic": "Filtratioin, Sorting",
    "difficulty": "Medium",
    "level": "2",
    "cluster": "Outer JOIN 2 (Post-Join Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c2",
    "description": "<div>\n\n<br>\nList out all the client details email address, whose age is between 25 to 35, along with the projects assigned to them in ascending order of their age and project ID. Also, use c for client_d and p for project, as alias name of tables.\n<br> \n</div>\n<br>\n<div >\n<b> Information about the table:</b>\n<br>\nTable <b>Employee:</b>\n<img src=\"https://files.codingninjas.in/bq-12762.PNG\">\n<br>\nTable <b>Project:</b>\n<img src=\"https://files.codingninjas.in/table_2-16577.png\">\n<br>\nTable <b>Client_d:</b>\n<img src = \"https://files.codingninjas.in/b3-12761.PNG\">\n<br>\n</div>\n<br>\n<div>\n<b>Output Table Structure:</b>\n<br>\n<img src = \"https://files.codingninjas.in/jt-query-6-16347.png\">\n<br>\n</div>\n<br>\n#### Note-1: Write keywords of syntax in uppercase alphabets.\n#### Note-2: Use client ID to link the two tables.",
    "brief_summary": "This problem tests the use of RIGHT OUTER JOIN with post-join filtering. It involves the client_d and project tables, requiring skills in joining tables using aliases, filtering by age range, and ordering results by age and project ID."
  },
  {
    "problem_id": 32589,
    "problem_name": "Average Selling Price",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Aggregation, Conditional Logic",
    "difficulty": "Medium",
    "level": "3",
    "cluster": "Outer JOIN 5 (Join with Aggregation)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c5",
    "description": "#### You are given two tables, Prices and UnitsSold, containing data about product prices and units sold respectively. The Prices table includes the product ID, start date, end date, and price of each product over specific periods. The UnitsSold table records the product ID, purchase date, and units sold for each transaction.<br> <br>\n\n#### Write a SQL query to calculate the average price per unit for each product based on the units sold during the periods specified in the Prices table. The purchase\\_date in the UnitsSold table should only be considered if it falls within the start\\_date and end\\_date of the corresponding product in the Prices table. If there are no matching sales for a product, the average price should be returned as 0. Round the result to 2 decimal places.\n<br>\n\n#### <i> <b> Hint: </b> \n<ul>\n<li> Use the LEFT JOIN function to answer this question. </li>\n<li> To calculate the average price of per unit you have to use the following formula: <br>\n<b> price per unit * number of units / total units </b>\n</li>\n</ul>\n\n</i> \n<br>\n\n#### <b>Input: </b>  <br>\n#### <b>Table Name 1: Prices </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003820_1718960857_Screenshot 2024-06-21 143642.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: UnitsSold </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004033_1720169444_Screenshot 2024-07-05 142021.png\" alt=\"Italian Trulli\"> \n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003830_1718962541_Screenshot 2024-06-21 150526.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests outer joins (LEFT JOIN) and conditional filtering based on date ranges. It involves the Prices and UnitsSold tables, requiring skills in joining tables, filtering by date intervals, and aggregation to compute weighted average prices per unit, handling cases with no sales."
  },
  {
    "problem_id": 32577,
    "problem_name": "Category-Wise Orders",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Aggregation",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Outer JOIN 5 (Join with Aggregation)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c3",
    "description": "#### Consider the following tables in a database:<br> <br> \n\n#### <b> Input: </b> <br>\n#### <b>Table Name 1: Categories</b> <br> \n\n<ul>\n<li>CategoryID (Primary Key): Unique identifier for each category. </li>\n<li>CategoryName: Name of the category. </li>\n<li>Description: Brief description of the category.</li>\n</ul>\n\n#### <b>Table Name 2: Products </b> <br> \n\n<ul>\n<li>ProductID (Primary Key): Unique identifier for each product. </li>\n<li>ProductName: Name of the product. </li>\n<li>CategoryID (Foreign Key): Identifier linking the product to its category.</li>\n<li>Unit: Measurement unit in which the product is sold.\n</li>\n<li>Price: Price of the product.</li>\n</ul>\n\n#### <b> Table Name 3: Order_Details </b> \n<ul>\n<li>OrderID (Foreign Key): Identifier linking the order to a specific order in the Orders table.</li> \n<li>ProductID (Foreign Key): Identifier linking the order to a specific product in the Products table.</li>\n<li>Quantity: The quantity of the product ordered in this order.</li>\n</ul>\n\n#### <b> Table Name 4: Orders </b> \n<ul>\n<li>OrderID (Primary Key): Unique identifier for each order.</li> \n<li>CustomerID (Foreign Key): Identifier linking the order to a specific customer in the Customers table.</li>\n<li>EmployeeID (Foreign Key): Identifier linking the order to a specific employee in the Employees table.</li>\n<li>OrderDate: Date when the order was placed.</li>\n<li>ShipperID (Foreign Key):  Identifier linking the order to a specific shipper in the Shippers table. </li>\n</ul>\n\n#### Write an SQL query to find the total number of products purchased for each category, including categories with no orders. Your query should include the category name and the total number of products and should account for categories that have no corresponding orders. <br> <br> \n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003803_1718951135_Screenshot 2024-06-21 115518.png\" alt=\"Italian Trulli\"> \n\n<i> <b> NOTE: </b> The output format does not contain all the rows present in the returned table. </i>",
    "brief_summary": "This problem tests the use of LEFT OUTER JOIN to include all categories, even those without orders. It involves the Categories, Products, Order_Details, and Orders tables. Key skills include joining multiple tables, filtering, and aggregating product quantities by category."
  },
  {
    "problem_id": 32590,
    "problem_name": "Zero Likes",
    "primary_topic": "Logical (Anti Join)",
    "secondary_topic": "Aggregation, having",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Outer JOIN 5 (Join with Aggregation)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c5",
    "description": "#### Given two tables, pages and page_likes, containing data about Facebook Pages and their respective likes, your objective is to craft a SQL query.<br> <br>\n\n#### This query should return the IDs of Facebook pages that have received zero likes. The output should be sorted in ascending order based on the page IDs. <br> <br> \n\n#### <b>Input: </b>  <br>\n#### <b>Table Name 1: Pages </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003831_1718964083_Screenshot 2024-06-21 153032.png\" alt=\"Italian Trulli\"> \n\n#### <b>Table Name 2: Page_likes </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003832_1718964094_Screenshot 2024-06-21 153052.png\" alt=\"Italian Trulli\"> \n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003833_1718964105_Screenshot 2024-06-21 153109.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests the concept of anti-joins to identify records without matches. It involves the \"pages\" and \"page_likes\" tables. Key skills include performing outer joins or subqueries, filtering for zero likes, and sorting results by page ID."
  },
  {
    "problem_id": 32586,
    "problem_name": "Count of Employees",
    "primary_topic": "Self Join",
    "secondary_topic": "Aggregation",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "SELF JOIN 2 (Hierarchical Query Test)",
    "topic_id": "self_join",
    "cluster_id": "self_c2",
    "description": "#### Given a table Employees containing information about employees and their managers, including their respective ages, write an SQL query to retrieve the IDs and names of all managers, along with the count of employees directly reporting to them and the average age of those employees (rounded to the nearest integer).\n\n<br> \n\n#### <I> <b> Hints: </b> Use the concept of Self Join to answer this question. </i>\n \n<br> \n\n#### <b>Input: </b>  <br>\n#### <b>Table Name: Employees </b>  <br> \n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003815_1718959143_Screenshot 2024-06-21 140819.png\" alt=\"Italian Trulli\"> \n\n\n\n#### <b> Output: </b>\n<img src=\"https://ninjasfiles.s3.amazonaws.com/asset_0000000000003839_1718971495_Screenshot 2024-06-21 173428.png\" alt=\"Italian Trulli\">",
    "brief_summary": "This problem tests the concept of self join on the Employees table to analyze hierarchical relationships. Key skills include performing self joins, filtering managers, and using aggregation functions like COUNT and AVG to calculate direct reports and their average age."
  },
  {
    "problem_id": 38216,
    "problem_name": "Well Paid Employees",
    "primary_topic": "Self Join",
    "secondary_topic": "Filtration",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "SELF JOIN 3 (Intra-Table Comparison Test)",
    "topic_id": "self_join",
    "cluster_id": "self_c3",
    "description": "#### As part of a salary review process, the company wants to ensure that no employees are earning more than their direct managers. Your task is to identify any employees who have a higher salary than their direct manager.\n<br>\n\n#### Write a query that returns the employee's ID and name for each employee who earns more than their direct manager.\n<br>\n\n#### Table: <b>employee</b>\n<br>\n\n<table style=\"border:1px black; border-collapse: collapse; width:35%\">\n<thead>\n<tr>\n<th style=\"border:1px solid black;\">&nbsp;Column Name &nbsp;</th>\n<th style=\"border:1px solid black;\">&nbsp;Data Type &nbsp;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"border:1px solid black;\"> &nbsp;employee_id </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;name   </td>\n<td style=\"border:1px solid black;\">&nbsp;VARCHAR</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;salary</td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;department_id</td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n<tr>\n<td style=\"border:1px solid black;\">&nbsp;manager_id   </td>\n<td style=\"border:1px solid black;\">&nbsp;INT</td>\n</tr>\n</tbody>\n</table>\n\n<br/>\n\n\n##### Expected Output:\n<br>\n\n<img src = \"https://ninjasfiles.s3.amazonaws.com/asset_0000000000004803_1740723658_i3.png\">\n\n<br>\n\n##### Explanation:\n<br>\n\n<li> Olivia Smith earns $7,000, which is higher than her direct manager, William Davis, who earns $6,800. Therefore, Olivia is included in the output.",
    "brief_summary": "This problem tests the concept of self join on a single employee table to compare employees with their direct managers. Key skills include performing self joins, filtering based on salary comparison, and understanding hierarchical relationships within the same table."
  },
  {
    "problem_id": 13632,
    "problem_name": "IMDb Genre",
    "primary_topic": "Outer Join (left)",
    "secondary_topic": "Filtration",
    "difficulty": "Hard",
    "level": "1",
    "cluster": "Outer Join 2 (Post-Join Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c2",
    "description": "#### Print the genre and the maximum net profit among all the movies of that genre released in 2012 per genre. (Download the dataset from console)\n\n##### Note:  \n    1. Do not print any row where either genre or the net profit is empty/null.\n    2. net_profit = Domestic + Worldwide - Budget\n    3. Keep the name of the columns as 'genre' and 'net_profit'\n    4. The genres should be printed in alphabetical order.",
    "brief_summary": "This problem tests outer joins with post-join filtering, involving movie and genre-related tables. Key skills include performing left joins, calculating net profit using arithmetic operations, filtering out null values, grouping by genre, aggregating with max, and ordering results alphabetically."
  },
  {
    "problem_id": 14370,
    "problem_name": "Number of Comments per Post",
    "primary_topic": "Self Join",
    "secondary_topic": "Logic & Aggregation",
    "difficulty": "Medium",
    "level": "2",
    "cluster": "Self Join 2 (Hierarchical Query Test)",
    "topic_id": "self_join",
    "cluster_id": "self_c2",
    "description": "Table: Submissions\n\n    +---------------+----------+\n    | Column Name   | Type     |\n    +---------------+----------+\n    | sub_id        | int      |\n    | parent_id     | int      |\n    +---------------+----------+\n    There is no primary key for this table, it may have duplicate rows.\n    Each row can be a post or comment on the post.\n    parent_id is null for posts.\n    parent_id for comments is sub_id for another post in the table.\n \n\n    Write an SQL query to find number of comments per each post.\n\n    Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.\n\n    Submissions may contain duplicate comments. You should count the number of unique comments per post.\n\n    Submissions may contain duplicate posts. You should treat them as one post.\n\n    The query result format is in the following example:\n\n    Submissions table:\n    +---------+------------+\n    | sub_id  | parent_id  |\n    +---------+------------+\n    | 1       | Null       |\n    | 2       | Null       |\n    | 1       | Null       |\n    | 12      | Null       |\n    | 3       | 1          |\n    | 5       | 2          |\n    | 3       | 1          |\n    | 4       | 1          |\n    | 9       | 1          |\n    | 10      | 2          |\n    | 6       | 7          |\n    +---------+------------+\n\n     Result table:\n    +---------+--------------------+\n    | post_id | number_of_comments |\n    +---------+--------------------+\n    | 1       | 3                  |\n    | 2       | 2                  |\n    | 12      | 0                  |\n    +---------+--------------------+\n\n    The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once.\n    The post with id 2 has two comments in the table with id 5 and 10.\n    The post with id 12 has no comments in the table.\n    The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.",
    "brief_summary": "This problem tests self-joins on a single table (Submissions) to relate posts and their comments. Key skills include handling duplicates, filtering nulls, performing aggregation (count distinct), and sorting results to count unique comments per post."
  },
  {
    "problem_id": 14404,
    "problem_name": "Customers Who Bought All Products",
    "primary_topic": "Inner Join",
    "secondary_topic": "Aggregation & Advanced Filtering",
    "difficulty": "Medium",
    "level": "3",
    "cluster": "Inner Join 5 (Join with Aggregation)",
    "topic_id": "Inner_join",
    "cluster_id": "inner_5",
    "description": "Table: Customer\n\n    +-------------+---------+\n    | Column Name | Type    |\n    +-------------+---------+\n    | customer_id | int     |\n    | product_key | int     |\n    +-------------+---------+\n    product_key is a foreign key to Product table.\n    \n\n    Table: Product\n\n    +-------------+---------+\n    | Column Name | Type    |\n    +-------------+---------+\n    | product_key | int     |\n    +-------------+---------+\n    product_key is the primary key column for this table.\n    \n\n    Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table.\n\n    Return the result table in any order.\n\n    The query result format is in the following example:\n\n    \n\n    Customer table:\n    +-------------+-------------+\n    | customer_id | product_key |\n    +-------------+-------------+\n    | 1           | 5           |\n    | 2           | 6           |\n    | 3           | 5           |\n    | 3           | 6           |\n    | 1           | 6           |\n    +-------------+-------------+\n\n    Product table:\n    +-------------+\n    | product_key |\n    +-------------+\n    | 5           |\n    | 6           |\n    +-------------+\n\n    Result table:\n    +-------------+\n    | customer_id |\n    +-------------+\n    | 1           |\n    | 3           |\n    +-------------+\n    The customers who bought all the products (5 and 6) are customers with id 1 and 3.",
    "brief_summary": "This problem tests the concept of inner joins combined with aggregation to identify customers who purchased every product. It involves the Customer and Product tables, requiring skills in joining tables, grouping data, and filtering results based on counts to ensure complete product coverage per customer."
  },
  {
    "problem_id": 14512,
    "problem_name": "Human Traffic of Stadium",
    "primary_topic": "Self Join",
    "secondary_topic": "Pattern Matching",
    "difficulty": "Medium",
    "level": "3",
    "cluster": "Self Join 3 (Consecutive Pattern Detection)",
    "topic_id": "Self_join",
    "cluster_id": "self_c3",
    "description": "Table: Stadium\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | id            | int     |\n    | visit_date    | date    |\n    | people        | int     |\n    +---------------+---------+\n    visit_date is the primary key for this table.\n    Each row of this table contains the visit date and visit id to the stadium with the number of people during the visit.\n    No two rows will have the same visit_date, and as the id increases, the dates increase as well.\n    \n\n    Write an SQL query to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each.\n\n    Return the result table ordered by visit_date in ascending order.\n\n    The query result format is in the following example.\n\n    \n\n    Stadium table:\n    +------+------------+-----------+\n    | id   | visit_date | people    |\n    +------+------------+-----------+\n    | 1    | 2017-01-01 | 10        |\n    | 2    | 2017-01-02 | 109       |\n    | 3    | 2017-01-03 | 150       |\n    | 4    | 2017-01-04 | 99        |\n    | 5    | 2017-01-05 | 145       |\n    | 6    | 2017-01-06 | 1455      |\n    | 7    | 2017-01-07 | 199       |\n    | 8    | 2017-01-09 | 188       |\n    +------+------------+-----------+\n\n    Result table:\n    +------+------------+-----------+\n    | id   | visit_date | people    |\n    +------+------------+-----------+\n    | 5    | 2017-01-05 | 145       |\n    | 6    | 2017-01-06 | 1455      |\n    | 7    | 2017-01-07 | 199       |\n    | 8    | 2017-01-09 | 188       |\n    +------+------------+-----------+\n    The four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has >= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7.\n    The rows with ids 2 and 3 are not included because we need at least three consecutive ids.",
    "brief_summary": "This problem tests the SQL concept of self join to identify consecutive patterns in a single table. It involves the Stadium table and requires skills in self joins, filtering rows based on conditions, and ordering results by date."
  },
  {
    "problem_id": 14518,
    "problem_name": "NPV Queries",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Null Value Handling",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Inner Join 1 (Basic Data Augmentation)",
    "topic_id": "Inner_join",
    "cluster_id": "inner_c1",
    "description": "Table: NPV\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | id            | int     |\n    | year          | int     |\n    | npv           | int     |\n    +---------------+---------+\n    (id, year) is the primary key of this table.\n    The table has information about the id and the year of each inventory and the corresponding net present value.\n    \n\n    Table: Queries\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | id            | int     |\n    | year          | int     |\n    +---------------+---------+\n    (id, year) is the primary key of this table.\n    The table has information about the id and the year of each inventory query.\n    \n\n    Write an SQL query to find the npv of all each query of queries table.\n\n    Return the result table in any order.\n\n    The query result format is in the following example:\n\n    NPV table:\n    +------+--------+--------+\n    | id   | year   | npv    |\n    +------+--------+--------+\n    | 1    | 2018   | 100    |\n    | 7    | 2020   | 30     |\n    | 13   | 2019   | 40     |\n    | 1    | 2019   | 113    |\n    | 2    | 2008   | 121    |\n    | 3    | 2009   | 12     |\n    | 11   | 2020   | 99     |\n    | 7    | 2019   | 0      |\n    +------+--------+--------+\n\n    Queries table:\n    +------+--------+\n    | id   | year   |\n    +------+--------+\n    | 1    | 2019   |\n    | 2    | 2008   |\n    | 3    | 2009   |\n    | 7    | 2018   |\n    | 7    | 2019   |\n    | 7    | 2020   |\n    | 13   | 2019   |\n    +------+--------+\n\n    Result table:\n    +------+--------+--------+\n    | id   | year   | npv    |\n    +------+--------+--------+\n    | 1    | 2019   | 113    |\n    | 2    | 2008   | 121    |\n    | 3    | 2009   | 12     |\n    | 7    | 2018   | 0      |\n    | 7    | 2019   | 0      |\n    | 7    | 2020   | 30     |\n    | 13   | 2019   | 40     |\n    +------+--------+--------+\n\n    The npv value of (7, 2018) is not present in the NPV table, we consider it 0.\n    The npv values of all other queries can be found in the NPV table.",
    "brief_summary": "This problem tests the use of left outer joins to combine two tables, NPV and Queries, ensuring all query records are retained while matching npv values. Key skills include performing left joins and handling nulls by substituting missing npv values with zero."
  },
  {
    "problem_id": 14763,
    "problem_name": "Spotify Sessions",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Filtration",
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Outer Join 4 (Exclusion Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c4",
    "description": "#### \n\n    Table: Playback\n\n    +-------------+------+\n    | Column Name | Type |\n    +-------------+------+\n    | session_id  | int  |\n    | customer_id | int  |\n    | start_time  | int  |\n    | end_time    | int  |\n    +-------------+------+\n    session_id is the primary key for this table.\n    customer_id is the ID of the customer watching this session.\n    The session runs during the inclusive interval between start_time and end_time.\n    It is guaranteed that start_time <= end_time and that two sessions for the same customer do not intersect.\n \n\n    Table: Ads\n\n     +-------------+------+\n     | Column Name | Type |\n     +-------------+------+\n     | ad_id       | int  |\n     | customer_id | int  |\n     | timestamp   | int  |\n     +-------------+------+\n    ad_id is the primary key for this table.\n    Customer_id is the ID of the customer viewing this ad.\n    Timestamp is the moment of time at which the ad was shown.\n \n\n    Write an SQL query to report all the sessions that did not get shown any ads.\n\n    Return the result table in any order.\n\n    The query result format is in the following example:\n\n \n\n    Playback table:\n\n    +------------+-------------+------------+----------+\n    | session_id | customer_id | start_time | end_time |\n    +------------+-------------+------------+----------+\n    | 1          | 1           | 1          | 5        |\n    | 2          | 1           | 15         | 23       |\n    | 3          | 2           | 10         | 12       |\n    | 4          | 2           | 17         | 28       |\n    | 5          | 2           | 2          | 8        |\n    +------------+-------------+------------+----------+\n\n    Ads table:\n\n    +-------+-------------+-----------+\n    | ad_id | customer_id | timestamp |\n    +-------+-------------+-----------+\n    | 1     | 1           | 5         |\n    | 2     | 2           | 17        |\n    | 3     | 2           | 20        |\n    +-------+-------------+-----------+\n\n    Result table:\n\n    +------------+\n    | session_id |\n    +------------+\n    | 2          |\n    | 3          |\n    | 5          |\n    +------------+\n\n    The ad with ID 1 was shown to user 1 at time 5 while they were in session 1.\n    The ad with ID 2 was shown to user 2 at time 17 while they were in session 4.\n    The ad with ID 3 was shown to user 2 at time 20 while they were in session 4. \n    We can see that sessions 1 and 4 had at least one ad. Sessions 2, 3, and 5 did not have any ads, so we return them.",
    "brief_summary": "This problem tests the use of left outer joins for exclusion filtering between two tables: Playback and Ads. Key skills include joining on customer_id with time range conditions, filtering unmatched records, and understanding interval overlaps to identify sessions without ads."
  },
  {
    "problem_id": 15102,
    "problem_name": "SQL query - 10",
    "primary_topic": "Outer Join",
    "secondary_topic": "Set Operator",
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Outer Join 1 (Simulated Join with UNION)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c1",
    "description": "<div>\n\n<br>\nFormulate a MySQL query to list out all the projects(id, name) and employee's names (first, last) along with their respective Email id’s irrespective of the fact if that project is assigned or not and whether an employee is assigned any project or none.\n<br>\n</div>\n<br>\n<div >\n<b> Information about the table:</b>\n<br>\nTable <b>Employee: </b>:\n<br>\n<img src=\"https://files.codingninjas.in/so-6-t1-16341.png\">\n<br>\nTable <b>Project</b>:\n<br>\n<img src=\"https://files.codingninjas.in/so-6-t2-16342.png\">\n<br>\n</div>\n<br>\n<br>\n<div>\n<b>Output Table Structure:</b>\n<br>\n<img src = \"https://files.codingninjas.in/so-6-16340.png\">\n<br>\n</div>\n<br>\n#### Hint: Use Full Join, but MySql doesn’t support the “Full Join” clause. \n#### Note-1: Write keywords of syntax in uppercase alphabets.\n#### Note-2: Use employee ID to link the two tables.",
    "brief_summary": "This problem tests the concept of full outer joins using UNION to simulate it in MySQL. It involves the Employee and Project tables, requiring skills in joins, specifically left and right joins, along with filtering and combining results to list all projects and employees regardless of assignments."
  },
  {
    "problem_id": 13630,
    "problem_name": "IMDb Metacritic Rating",
    "primary_topic": "Outer Join (left)",
    "secondary_topic": "Filtration",
    "difficulty": "Medium",
    "level": "2",
    "cluster": "Outer Join 2 (Post-Join Filtering)",
    "topic_id": "outer_join",
    "cluster_id": "outer_c2",
    "description": "#### Print the title and ratings of the movies released in 2012 whose metacritic rating is more than 60 and Domestic collections exceed 10 Crores. (Download the dataset from console)",
    "brief_summary": "This problem tests the use of left outer joins to combine movie and rating data. It involves tables with movie details, ratings, and collections. Key skills include performing outer joins, filtering on multiple conditions, and selecting specific columns."
  },
  {
    "problem_id": 14537,
    "problem_name": "Product's Worth Over Invoices",
    "primary_topic": "Inner Join",
    "secondary_topic": "Aggregation",
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Inner Join 5 (Join with Aggregation)",
    "topic_id": "Inner_join",
    "cluster_id": "inner_5",
    "description": "Table: Product\n\n    +-------------+---------+\n    | Column Name | Type    |\n    +-------------+---------+\n    | product_id  | int     |\n    | name        | varchar |\n    +-------------+---------+\n    product_id is the primary key for this table.\n    This table contains the ID and the name of the product. The name consists of only lowercase English letters. No two products have the same name.\n    \n\n    Table: Invoice\n\n    +-------------+------+\n    | Column Name | Type |\n    +-------------+------+\n    | invoice_id  | int  |\n    | product_id  | int  |\n    | rest        | int  |\n    | paid        | int  |\n    | canceled    | int  |\n    | refunded    | int  |\n    +-------------+------+\n    invoice_id is the primary key for this table and the id of this invoice.\n    product_id is the id of the product for this invoice.\n    rest is the amount left to pay for this invoice.\n    paid is the amount paid for this invoice.\n    canceled is the amount canceled for this invoice.\n    refunded is the amount refunded for this invoice.\n    \n\n    Write an SQL query that will, for all products, return each product name with total amount due, paid, canceled, and refunded across all invoices.\n\n    Return the result table ordered by product_name.\n\n    The query result format is in the following example:\n\n    \n\n    Product table:\n    +------------+-------+\n    | product_id | name  |\n    +------------+-------+\n    | 0          | ham   |\n    | 1          | bacon |\n    +------------+-------+\n    Invoice table:\n    +------------+------------+------+------+----------+----------+\n    | invoice_id | product_id | rest | paid | canceled | refunded |\n    +------------+------------+------+------+----------+----------+\n    | 23         | 0          | 2    | 0    | 5        | 0        |\n    | 12         | 0          | 0    | 4    | 0        | 3        |\n    | 1          | 1          | 1    | 1    | 0        | 1        |\n    | 2          | 1          | 1    | 0    | 1        | 1        |\n    | 3          | 1          | 0    | 1    | 1        | 1        |\n    | 4          | 1          | 1    | 1    | 1        | 0        |\n    +------------+------------+------+------+----------+----------+\n    Result table:\n    +-------+------+------+----------+----------+\n    | name  | rest | paid | canceled | refunded |\n    +-------+------+------+----------+----------+\n    | bacon | 3    | 3    | 3        | 3        |\n    | ham   | 2    | 4    | 5        | 3        |\n    +-------+------+------+----------+----------+\n    - The amount of money left to pay for bacon is 1 + 1 + 0 + 1 = 3\n    - The amount of money paid for bacon is 1 + 0 + 1 + 1 = 3\n    - The amount of money canceled for bacon is 0 + 1 + 1 + 1 = 3\n    - The amount of money refunded for bacon is 1 + 1 + 1 + 0 = 3\n    - The amount of money left to pay for ham is 2 + 0 = 2\n    - The amount of money paid for ham is 0 + 4 = 4\n    - The amount of money canceled for ham is 5 + 0 = 5\n    - The amount of money refunded for ham is 0 + 3 = 3",
    "brief_summary": "This problem tests inner joins and aggregation by combining Product and Invoice tables. It requires joining on product_id, grouping by product name, and summing multiple invoice-related columns, demonstrating skills in joins, filtering, and aggregation functions."
  },
  {
    "problem_id": 14617,
    "problem_name": "All Valid Triplets That Can Represent a Country",
    "primary_topic": "Cross Join",
    "secondary_topic": "Filtration",
    "difficulty": "Medium",
    "level": "3",
    "cluster": "Cross Join 1 (Generating Permutations)",
    "topic_id": "cross_join",
    "cluster_id": "cross_1",
    "description": "Table: SchoolA\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | student_id    | int     |\n    | student_name  | varchar |\n    +---------------+---------+\n    student_id is the primary key for this table.\n    Each row of this table contains the name and the id of a student in school A.\n    All student_name are distinct.\n    \n\n    Table: SchoolB\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | student_id    | int     |\n    | student_name  | varchar |\n    +---------------+---------+\n    student_id is the primary key for this table.\n    Each row of this table contains the name and the id of a student in school B.\n    All student_name are distinct.\n    \n\n    Table: SchoolC\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | student_id    | int     |\n    | student_name  | varchar |\n    +---------------+---------+\n    student_id is the primary key for this table.\n    Each row of this table contains the name and the id of a student in school C.\n    All student_name are distinct.\n    \n\n    There is a country with three schools, where each student is enrolled in exactly one school. The country is joining a competition and wants to select one student from each school to represent the country such that:\n\n    member_A is selected from SchoolA,\n    member_B is selected from SchoolB,\n    member_C is selected from SchoolC, and\n    The selected students' names and IDs are pairwise distinct (i.e. no two students share the same name, and no two students share the same ID).\n    Write an SQL query to find all the possible triplets representing the country under the given constraints.\n\n    Return the result table in any order.\n\n    The query result format is in the following example.\n\n    \n\n    SchoolA table:\n    +------------+--------------+\n    | student_id | student_name |\n    +------------+--------------+\n    | 1          | Alice        |\n    | 2          | Bob          |\n    +------------+--------------+\n\n    SchoolB table:\n    +------------+--------------+\n    | student_id | student_name |\n    +------------+--------------+\n    | 3          | Tom          |\n    +------------+--------------+\n\n    SchoolC table:\n    +------------+--------------+\n    | student_id | student_name |\n    +------------+--------------+\n    | 3          | Tom          |\n    | 2          | Jerry        |\n    | 10         | Alice        |\n    +------------+--------------+\n\n    Result table:\n    +----------+----------+----------+\n    | member_A | member_B | member_C |\n    +----------+----------+----------+\n    | Alice    | Tom      | Jerry    |\n    | Bob      | Tom      | Alice    |\n    +----------+----------+----------+\n    Let us see all the possible triplets.\n    - (Alice, Tom, Tom) --> Rejected because member_B and member_C have the same name and the same ID.\n    - (Alice, Tom, Jerry) --> Valid triplet.\n    - (Alice, Tom, Alice) --> Rejected because member_A and member_C have the same name.\n    - (Bob, Tom, Tom) --> Rejected because member_B and member_C have the same name and the same ID.\n    - (Bob, Tom, Jerry) --> Rejected because member_A and member_C have the same ID.\n    - (Bob, Tom, Alice) --> Valid triplet.",
    "brief_summary": "This problem tests the use of cross joins to generate all possible triplets from three tables (SchoolA, SchoolB, SchoolC). Key skills include performing cross joins, filtering results based on distinctness of student IDs and names, and ensuring no duplicates across combined rows."
  },
  {
    "problem_id": 20289,
    "problem_name": "JT-NQ-5",
    "primary_topic": "Inner Join",
    "secondary_topic": null,
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Inner Join 2 (Multi-Table Linking)",
    "topic_id": "inner_join",
    "cluster_id": "inner_2",
    "description": "<div>\n\n<br>\nWrite a SQL query to display the supplier name, product name and their active status in order of the quantity supplied. The tables (Supplier, SP and Product) should be joined in the same order as stated above.\n<br>\n</div>\n<br>\n<div >\n<b> Information about the table:</b>\n<br>\nTable <b>Product</b>:\n<br>\n <img src =\"https://files.codingninjas.in/product_table-16305.png\">\n<br>\nTable <b>Supplier</b>:\n<br>\n<img src=\"https://files.codingninjas.in/supplier_table-16308.png\">\n<br>\nTable <b>SP</b>:\n<br>\n<img src =\" https://files.codingninjas.in/sp_table-16306.png\">\n</div>\n<br>\n<br>\n<div>\n<b>Output Table Structure:</b>\n<br>\n<img src = \"https://files.codingninjas.in/jt-nq-6-16609.png\">\n<br>\n</div>\n<br>\n#### Note: Write keywords of syntax in uppercase alphabets.",
    "brief_summary": "This problem tests the concept of INNER JOIN across multiple tables (Supplier, SP, Product) to link related data. Key skills include performing multi-table joins in a specified order, filtering, and ordering results by quantity supplied."
  },
  {
    "problem_id": 14305,
    "problem_name": "Shortest Distance",
    "primary_topic": "Self Join",
    "secondary_topic": "Calculations",
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Self Join 2 (Relational Arithmetic)",
    "topic_id": "self_join",
    "cluster_id": "self_2",
    "description": "Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.\n\n    Write a query to find the shortest distance between two points in these points.\n \n\n    | x   |\n    |-----|\n    | -1  |\n    | 0   |\n    | 2   |\n \n    The shortest distance is '1' obviously, which is from point '-1' to '0'. So the output is as below:\n \n\n    | shortest|\n    |---------|\n    |  1      |",
    "brief_summary": "This problem tests the SQL concept of self join by using the same table twice to compare rows. It involves the \"point\" table and requires skills in self joining, calculating differences, filtering for positive distances, and aggregation to find the minimum value."
  },
  {
    "problem_id": 14325,
    "problem_name": "Employees Earning More Than Their Manager",
    "primary_topic": "Self Join",
    "secondary_topic": "Filtration",
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Self Join 1 (Hierarchical Comparison)",
    "topic_id": "self_join",
    "cluster_id": "self_1",
    "description": "Employees Earning More Than Their Managers\n     The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n\n    +----+-------+--------+-----------+\n    | Id | Name  | Salary | ManagerId |\n    +----+-------+--------+-----------+\n    | 1  | Joe   | 70000  | 3         |\n    | 2  | Henry | 80000  | 4         |\n    | 3  | Sam   | 60000  | NULL      |\n    | 4  | Max   | 90000  | NULL      |\n    +----+-------+--------+-----------+\n    Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n\n    +----------+\n    | Employee |\n    +----------+\n    | Joe      |\n    +----------+",
    "brief_summary": "This problem tests the self join concept using the Employee table to compare employees' salaries with their managers'. Key skills include performing self joins, filtering based on salary comparison, and handling hierarchical data relationships."
  },
  {
    "problem_id": 14525,
    "problem_name": "Trusted Contacts of User",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Aggregration and sorting",
    "difficulty": "Hard",
    "level": "1",
    "cluster": "Outer Join 5 (Multi-Metric Aggregation)",
    "topic_id": "outer_join",
    "cluster_id": "outer_1",
    "description": "Table: Customers\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | customer_id   | int     |\n    | customer_name | varchar |\n    | email         | varchar |\n    +---------------+---------+\n    customer_id is the primary key for this table.\n    Each row of this table contains the name and the email of a customer of an online shop.\n    \n\n    Table: Contacts\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | user_id       | id      |\n    | contact_name  | varchar |\n    | contact_email | varchar |\n    +---------------+---------+\n    (user_id, contact_email) is the primary key for this table.\n    Each row of this table contains the name and email of one contact of customer with user_id.\n    This table contains information about people each customer trust. The contact may or may not exist in the Customers table.\n\n    \n\n    Table: Invoices\n\n    +--------------+---------+\n    | Column Name  | Type    |\n    +--------------+---------+\n    | invoice_id   | int     |\n    | price        | int     |\n    | user_id      | int     |\n    +--------------+---------+\n    invoice_id is the primary key for this table.\n    Each row of this table indicates that user_id has an invoice with invoice_id and a price.\n    \n\n    Write an SQL query to find the following for each invoice_id:\n\n    customer_name: The name of the customer the invoice is related to.\n    price: The price of the invoice.\n    contacts_cnt: The number of contacts related to the customer.\n    trusted_contacts_cnt: The number of contacts related to the customer and at the same time they are customers to the shop. (i.e His/Her email exists in the Customers table.)\n    Order the result table by invoice_id.\n\n    The query result format is in the following example:\n\n    Customers table:\n    +-------------+---------------+--------------------+\n    | customer_id | customer_name | email              |\n    +-------------+---------------+--------------------+\n    | 1           | Alice         | alice@codingninjas.com |\n    | 2           | Bob           | bob@codingninjas.com   |\n    | 13          | John          | john@codingninjas.com  |\n    | 6           | Alex          | alex@codingninjas.com  |\n    +-------------+---------------+--------------------+\n    Contacts table:\n    +-------------+--------------+--------------------+\n    | user_id     | contact_name | contact_email      |\n    +-------------+--------------+--------------------+\n    | 1           | Bob          | bob@codingninjas.com   |\n    | 1           | John         | john@codingninjas.com  |\n    | 1           | Jal          | jal@codingninjas.com   |\n    | 2           | Omar         | omar@codingninjas.com  |\n    | 2           | Meir         | meir@codingninjas.com  |\n    | 6           | Alice        | alice@codingninjas.com |\n    +-------------+--------------+--------------------+\n    Invoices table:\n    +------------+-------+---------+\n    | invoice_id | price | user_id |\n    +------------+-------+---------+\n    | 77         | 100   | 1       |\n    | 88         | 200   | 1       |\n    | 99         | 300   | 2       |\n    | 66         | 400   | 2       |\n    | 55         | 500   | 13      |\n    | 44         | 60    | 6       |\n    +------------+-------+---------+\n    Result table:\n    +------------+---------------+-------+--------------+----------------------+\n    | invoice_id | customer_name | price | contacts_cnt | trusted_contacts_cnt |\n    +------------+---------------+-------+--------------+----------------------+\n    | 44         | Alex          | 60    | 1            | 1                    |\n    | 55         | John          | 500   | 0            | 0                    |\n    | 66         | Bob           | 400   | 2            | 0                    |\n    | 77         | Alice         | 100   | 3            | 2                    |\n    | 88         | Alice         | 200   | 3            | 2                    |\n    | 99         | Bob           | 300   | 2            | 0                    |\n    +------------+---------------+-------+--------------+----------------------+\n    Alice has three contacts, two of them are trusted contacts (Bob and John).\n    Bob has two contacts, none of them is a trusted contact.\n    Alex has one contact and it is a trusted contact (Alice).\n    John doesn't have any contacts.",
    "brief_summary": "This problem tests outer joins and multi-metric aggregation across three tables: Customers, Contacts, and Invoices. Key skills include left joins to link customers with contacts, filtering to identify trusted contacts, and aggregation to count total and trusted contacts per invoice."
  },
  {
    "problem_id": 20286,
    "problem_name": "JT-NQ-2",
    "primary_topic": "Inner Join",
    "secondary_topic": "Filteration",
    "difficulty": "Easy",
    "level": "2",
    "cluster": "Inner Join 3 (Linking with Filtration)",
    "topic_id": "inner_join",
    "cluster_id": "inner_3",
    "description": "<div>\n\n<br>\nWrite a SQL query to find the name, colour and quantity of the product supplied by sahil. The tables (Supplier, SP and Product) should be joined in the same order as stated above. \n<br>\n</div>\n<br>\n<div >\n<b> Information about the table:</b>\n<br>\nTable <b>Product</b>:\n<br>\n <img src =\"https://files.codingninjas.in/product_table-16305.png\">\n<br>\nTable <b>Supplier</b>:\n<br>\n<img src=\"https://files.codingninjas.in/supplier_table-16308.png\">\n<br>\nTable <b>SP</b>:\n<br>\n<img src =\" https://files.codingninjas.in/sp_table-16306.png\">\n</div>\n<br>\n<br>\n<div>\n<b>Output Table Structure:</b>\n<br>\n<img src = \"https://files.codingninjas.in/jt-nq-2-16605.png\">\n<br>\n</div>\n<br>\n#### Note: Write keywords of syntax in uppercase alphabets.",
    "brief_summary": "This problem tests the concept of inner joins involving three tables: Supplier, SP, and Product. Key skills include performing ordered inner joins, filtering results based on supplier name, and selecting specific columns without aggregation."
  },
  {
    "problem_id": 14514,
    "problem_name": "Warehouse Manager",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Aggregation",
    "difficulty": "Easy",
    "level": "3",
    "cluster": "Left Join 5 (Aggregating Optional Data)",
    "topic_id": "outer_join",
    "cluster_id": "outer_5",
    "description": "Table: Warehouse\n\n    +--------------+---------+\n    | Column Name  | Type    |\n    +--------------+---------+\n    | name         | varchar |\n    | product_id   | int     |\n    | units        | int     |\n    +--------------+---------+\n    (name, product_id) is the primary key for this table.\n    Each row of this table contains the information of the products in each warehouse.\n    \n\n    Table: Products\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | product_id    | int     |\n    | product_name  | varchar |\n    | Width         | int     |\n    | Length        | int     |\n    | Height        | int     |\n    +---------------+---------+\n    product_id is the primary key for this table.\n    Each row of this table contains the information about the product dimensions (Width, Lenght and Height) in feets of each product.\n    \n\n    Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse.\n\n    warehouse_name\n    volume\n    Return the result table in any order.\n\n    The query result format is in the following example.\n\n    \n\n    Warehouse table:\n    +------------+--------------+-------------+\n    | name       | product_id   | units       |\n    +------------+--------------+-------------+\n    | LCHouse1   | 1            | 1           |\n    | LCHouse1   | 2            | 10          |\n    | LCHouse1   | 3            | 5           |\n    | LCHouse2   | 1            | 2           |\n    | LCHouse2   | 2            | 2           |\n    | LCHouse3   | 4            | 1           |\n    +------------+--------------+-------------+\n\n    Products table:\n    +------------+--------------+------------+----------+-----------+\n    | product_id | product_name | Width      | Length   | Height    |\n    +------------+--------------+------------+----------+-----------+\n    | 1          | LC-TV        | 5          | 50       | 40        |\n    | 2          | LC-KeyChain  | 5          | 5        | 5         |\n    | 3          | LC-Phone     | 2          | 10       | 10        |\n    | 4          | LC-T-Shirt   | 4          | 10       | 20        |\n    +------------+--------------+------------+----------+-----------+\n\n    Result table:\n    +----------------+------------+\n    | warehouse_name | volume     | \n    +----------------+------------+\n    | LCHouse1       | 12250      | \n    | LCHouse2       | 20250      |\n    | LCHouse3       | 800        |\n    +----------------+------------+\n    Volume of product_id = 1 (LC-TV), 5x50x40 = 10000\n    Volume of product_id = 2 (LC-KeyChain), 5x5x5 = 125 \n    Volume of product_id = 3 (LC-Phone), 2x10x10 = 200\n    Volume of product_id = 4 (LC-T-Shirt), 4x10x20 = 800\n    LCHouse1: 1 unit of LC-TV + 10 units of LC-KeyChain + 5 units of LC-Phone.\n            Total volume: 1*10000 + 10*125  + 5*200 = 12250 cubic feet\n    LCHouse2: 2 units of LC-TV + 2 units of LC-KeyChain.\n            Total volume: 2*10000 + 2*125 = 20250 cubic feet\n    LCHouse3: 1 unit of LC-T-Shirt.\n            Total volume: 1*800 = 800 cubic feet.",
    "brief_summary": "This problem tests the use of left outer joins to combine warehouse inventory with product dimensions. It involves the Warehouse and Products tables, requiring skills in joining, filtering optional data, and aggregating volume calculations by multiplying dimensions and units per warehouse."
  },
  {
    "problem_id": 14367,
    "problem_name": "Top Travellers",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": "Aggregation",
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Left Join 5 (Aggregating Optional Data)",
    "topic_id": "outer_join",
    "cluster_id": "outer_5",
    "description": "Table: Users\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | id            | int     |\n    | name          | varchar |\n    +---------------+---------+\n    id is the primary key for this table.\n    name is the name of the user.\n \n\n    Table: Rides\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | id            | int     |\n    | user_id       | int     |\n    | distance      | int     |\n    +---------------+---------+\n    id is the primary key for this table.\n    user_id is the id of the user who travelled the distance \"distance\".\n \n\n    Write an SQL query to report the distance travelled by each user.\n\n    Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order.\n\n    The query result format is in the following example.\n\n \n\n    Users table:\n    +------+-----------+\n    | id   | name      |\n    +------+-----------+\n    | 1    | Alice     |\n    | 2    | Bob       |\n    | 3    | Alex      |\n    | 4    | Donald    |\n    | 7    | Lee       |\n    | 13   | Jonathan  |\n    | 19   | Elvis     |\n    +------+-----------+\n\n    Rides table:\n    +------+----------+----------+\n    | id   | user_id  | distance |\n    +------+----------+----------+\n    | 1    | 1        | 120      |\n    | 2    | 2        | 317      |\n    | 3    | 3        | 222      |\n    | 4    | 7        | 100      |\n    | 5    | 13       | 312      |\n    | 6    | 19       | 50       |\n    | 7    | 7        | 120      |\n    | 8    | 19       | 400      |\n    | 9    | 7        | 230      |\n    +------+----------+----------+\n\n    Result table:\n    +----------+--------------------+\n    | name     | travelled_distance |\n    +----------+--------------------+\n    | Elvis    | 450                |\n    | Lee      | 450                |\n    | Bob      | 317                |\n    | Jonathan | 312                |\n    | Alex     | 222                |\n    | Alice    | 120                |\n    | Donald   | 0                  |\n    +----------+--------------------+\n    Elvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than Lee.\n    Bob, Jonathan, Alex and Alice have only one ride and we just order them by the total distances of the ride.\n    Donald didn't have any rides, the distance travelled by him is 0.",
    "brief_summary": "This problem tests the use of LEFT JOIN to combine Users and Rides tables, ensuring all users are included even without rides. Key skills include outer joins, aggregation (SUM), grouping, handling NULLs with COALESCE, and ordering results by aggregated distance and name."
  },
  {
    "problem_id": 14318,
    "problem_name": "Rising Temperature",
    "primary_topic": "Self Join",
    "secondary_topic": null,
    "difficulty": "Medium",
    "level": "1",
    "cluster": "Self Join 4 (Sequential Comparison)",
    "topic_id": "self_join",
    "cluster_id": "self_4",
    "description": "Table: Weather\n\n    +---------------+---------+\n    | Column Name   | Type    |\n    +---------------+---------+\n    | id            | int     |\n    | recordDate    | date    |\n    | temperature   | int     |\n    +---------------+---------+\n    id is the primary key for this table.\n    This table contains information about the temperature in a certain day.\n \n\n    Write an SQL query to find all dates' id with higher temperature compared to its previous dates (yesterday).\n\n    Return the result table in any order.\n\n    The query result format is in the following example:\n\n    Weather\n    +----+------------+-------------+\n    | id | recordDate | Temperature |\n    +----+------------+-------------+\n    | 1  | 2015-01-01 | 10          |\n    | 2  | 2015-01-02 | 25          |\n    | 3  | 2015-01-03 | 20          |\n    | 4  | 2015-01-04 | 30          |\n    +----+------------+-------------+\n\n    Result table:\n    +----+\n    | Id |\n    +----+\n    | 2  |\n    | 4  |\n   +----+\n\n    In 2015-01-02, temperature was higher than the previous day (10 -> 25).\n    In 2015-01-04, temperature was higher than the previous day (20 -> 30).",
    "brief_summary": "This problem tests the concept of self join using the Weather table to compare each day's temperature with the previous day. Key skills include performing self joins, date-based filtering, and sequential comparison without aggregation."
  },
  {
    "problem_id": 13633,
    "problem_name": "IMDb Max Weighted Rating",
    "primary_topic": "Outer Join",
    "secondary_topic": "Aggregation",
    "difficulty": "Hard",
    "level": "1",
    "cluster": "Outer Join 5 (Advanced Conditional Aggregation)",
    "topic_id": "outer_join",
    "cluster_id": "outer_5",
    "description": "#### Print the genre and the maximum weighted rating among all the movies of that genre released in 2014 per genre. (Download the dataset from console)\n\n##### Note:  \n    1. Do not print any row where either genre or the weighted rating is empty/null.\n    2.  weighted_rating = avgerge of (rating + metacritic/10.0)\n    3. Keep the name of the columns as 'genre' and 'weighted_rating'\n    4. The genres should be printed in alphabetical order.",
    "brief_summary": "This problem tests advanced conditional aggregation using outer joins on movie and genre tables. It requires joining tables, filtering out nulls, calculating weighted ratings by averaging rating and metacritic scores, grouping by genre, and ordering results alphabetically."
  },
  {
    "problem_id": 15079,
    "problem_name": "SQL Query - 4",
    "primary_topic": "Outer Join (Left)",
    "secondary_topic": null,
    "difficulty": "Easy",
    "level": "1",
    "cluster": "Left Join 1 (Basic Data Augmentation)",
    "topic_id": "easy_join",
    "cluster_id": "easy_1",
    "description": "<div>\n\n<br>\nFetch out each project allocated to which employee.\n<br> \n</div>\n<br>\n<div >\n<b> Information about the table:</b>\n<br>\nTable <b>Employee:</b>\n<img src=\"https://files.codingninjas.in/bq-12762.PNG\">\n<br>\nTable <b>Project:</b>\n<img src=\"https://files.codingninjas.in/table_2-16577.png\">\n<br>\nTable <b>Client_d:</b>\n<img src = \"https://files.codingninjas.in/b3-12761.PNG\">\n<br>\n</div>\n<br>\n<div>\n<b>Output Table Structure:</b>\n<br>\n<img src = \"https://files.codingninjas.in/jt-query-4-16345.png\">\n<br>\n</div>\n<br>\n#### Note-1: Write a SQL query to display the first name (EmpFname), last name (EmpLname), project ID (ProjectID), and project name (ProjectName) for all employees. Ensure that employees who do not have a project assigned are also included in the results. Use an appropriate join to achieve this.",
    "brief_summary": "This problem tests the concept of left outer joins to include all employees regardless of project assignment. It involves the Employee and Project tables. Key skills required are performing left joins and selecting relevant columns while handling cases with no matching projects."
  }
]